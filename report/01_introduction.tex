\section{Introduction}
\label{sec:introduction}

One of the main criteria when developing a key-value database(DB), is being able to handle large amounts of data while making the system available for multiple clients. DB systems, such as AmazonWeb Services, Microsoft Azure SQL and Oracle Database offer the combination of scalability and cost effectiveness.

Another important feature is elasticity which measures the ability of a system to dynamically scaled up or down. The key-value DB BigTable and PNUTS are great examples\cite{agrawal2011database}.

Amazon DynamoDB is a non-relational database system which provides single-digit millisecond latency \cite{amazon}, considering the system is used worldwide. Data records are stored with a primary or composite key and several attributes depending on client's request \cite{kalid2017big}. 

Apache Cassandra is another key-value based high scaled \cite{abadi2012consistency} DB system, which is known for managing some of the world's largest datasets on clusters with the help of thousands of nodes distributed amongst multiple data centres \cite{chebotko2015big}. Cassandra offers more flexibility regarding fault handling and managing wide range data, unlike BigTable and Dynamo \cite{kalid2017big}. The system focuses on high level of availability by scaling millions of read and write requests per second\cite{chebotko2015big}.

Our inspiration mainly came from the DB Redis. It rose in popularity after its creation in 2009 and got deployed by many big companies such as Instagram \cite{krieger2011instagram} and Twitter \cite{yu2014twitter}, which require enormous DBs and fast responses to the millions of users they serve. One of its multiple features is the Pub/Sub system \cite{redis2020pubsub}, added in March 2010 \cite{sanfilippo2010pubsub}. With it, clients are able to subscribe to a set of keys, namely topics, and receive an update whenever their associated values get overwritten. In this model, clients keep waiting for the server to send them an update. During that period, subscribers are expected to use only subscription related operations.

In our system, we wanted for there to be no distinction between publishers and subscribers with everyone being able to both publish and receive updates. Apart from that, access to the DB should still be possible. 

Thus, the way we modelled our system in the end, was having a many-to-many relationship of all subscribed clients, effectively, implementing a group chat functionality.


