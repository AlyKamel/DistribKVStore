\section{Background}
\label{sec:background}
In this section, we elaborate on some of the basic concepts that our key-value system depends on. First, we discuss the CAP theorem and analyse where our system lies on that spectrum. Then, we mention two design paradigms, namely BASE and ACID, and explain the differences between them.

\subsection{Key-value store}
Key-value stores are perhaps the simplest type of a NoSQL database. Values, which in our case are limited to strings, can be easily stored and retrieved just by providing the key they were assigned with. 

\subsection{Caching}
Caching is a way of storing information so that information can be retrieved faster on demand. A storage method, namely write trough, enables to write the information into the cache as well as in to the disk store simultaneously. Thus, the data will not only be returned quickly because of caching, it will be saved in the disk ensuring that no data will get lost in case of any partitions in the network. Since the write operation is performed two times the storage system has redundancy. One of the upsides of redundancy is tolerating loss of data. However, it increases the latency by making the response times longer.

\subsection{CAP Theorem}
\label{sec:background_cap} 
According to the CAP Theorem, distributed databases have three substantial properties to consider: consistency, availability and partition tolerance\cite{brewer2012cap}. Eric Brewer, the man behind the CAP theorem, stated that a distributed database can fulfil at most two of three properties\cite{brewer2000cap}:

\begin{itemize}
  \item Consistency: \\
  Clients are provided with fresh data, meaning the most up-to-date version of the data that got stored after the last write operation.
  \item Availability: \\
  Servers respond to the request of clients at all cases. Every non-failing node in the system must be able to serve the client in a reasonable amount of time\cite{gilbert2002brewer}.
  \item Partition tolerance: \\
  Whenever a server crashes, the rest of the system will still stay functional after the crash, without any information being lost.
\end{itemize}

Twelve years after from proposing the CAP theorem, Brewer mentioned that software engineers do not have to strictly abide to the 2 of 3 principle, it is rather a spectrum than a binary choice \cite{brewer2012cap}. In other words, a distributed database system can favour high level of consistency and partition tolerance by having low level of availability. Thus, the initial theorem is improved by not having to sacrifice availability completely in this case.

There are two design approaches for distributed database systems, namely ACID and BASE. According to Brewer, these two design approaches may be referred as opposites of each other\cite{brewer2012cap} because of their priorities and use cases. ACID approach is used most of the times for relational database systems (SQL) and focuses on consistency to maintain reliability. On the contrary BASE is more suitable for the non-relational database systems (NoSQL) concentrating on providing the client high level of availability\cite{brewer2000cap}.

\subsection{ACID}
\label{sec:background_acid}
ACID is a traditional design approach\cite{brewer2012cap} when it comes to large-scaled distributed systems. The main goal of ACID is that despite the system having partitions, the client should always be provided with consistent values. It is an acronym which stands for the four following properties:
\begin{itemize}
\item Atomicity:\\
A set of transactions succeed all at once or fail all together. In other words, it is an all or nothing strategy.
\item Consistency: \\
The system never contains any stale data. When a client wants to read from any server, the returned value must be the value from the last write commit by any client. All clients should always get the same result whenever they try to fetch the same information.
\item Isolation:\\
All transactions happen isolated from each other and do not affect each other. Thus, if one transaction fails, all others are undisturbed.
\item Durability:\\
Once a client is informed that a transaction has been successfully committed, even if a crash occurs, the transaction would still stay committed.
\end{itemize} 

\subsection{BASE}
\label{sec:background_base}
BASE, another design approach defined by Brewer, offers looser requirements than ACID\cite{brewer2012cap}. Non-relational database systems concentrating on high availability make use of the BASE approach, which sacrifices strong consistency in favour of being always accessible. Examples include huge storage services such as Amazon's Dynamo, Facebook's Cassandra or Google's BigTable, where millions of active users always expect the service to be available\cite{kalid2017big}. Nevertheless, there must be trade-offs. By not guaranteeing the consistency at all time, the system cost is reduced, and clients are happier, but a client might not get an immediate response to his request.

\begin{itemize}
  \item Basic Availability:\\
 Clients are guaranteed to get a quick response from the server without getting blocked, however the returned value may be stale, stated in other words, inconsistent with the latest version.
  \item Soft State:\\
Since stale data is permitted, servers never truly know whether they are currently up-to-date or if they still contain invalid data.
  \item Eventual Consistency:\\
If there are no updates in the system for a long time, then all servers will gradually become consistent. Since the time is not specified, servers are always in a soft state, as explained above.
\end{itemize}

    

